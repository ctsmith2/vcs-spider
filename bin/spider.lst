------- FILE spider.asm LEVEL 1 PASS 2
      1  10000 ????						; 8 Legs of Love game for Atari VCS/2600
      2  10000 ????						; Created by D Cooper Dalrymple 2018 - dcdalrymple.com
      3  10000 ????						; Licensed under GNU LGPL V3.0
      4  10000 ????						; Last revision: August 28th, 2018
      5  10000 ????
      6  10000 ????				       processor	6502
------- FILE vcs.h LEVEL 2 PASS 2
      0  10000 ????				       include	"vcs.h"
      1  10000 ????						; VCS.H
      2  10000 ????						; Version 1.05, 13/November/2003
      3  10000 ????
      4  10000 ????		00 69	    VERSION_VCS =	105
      5  10000 ????
      6  10000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      7  10000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  10000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
      9  10000 ????						;
     10  10000 ????						; This file defines hardware registers and memory mapping for the
     11  10000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     12  10000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  10000 ????						; available at at http://www.atari2600.org/dasm
     14  10000 ????						;
     15  10000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     16  10000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     17  10000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     18  10000 ????						; with your views.  Please contribute, if you think you can improve this
     19  10000 ????						; file!
     20  10000 ????						;
     21  10000 ????						; Latest Revisions...
     22  10000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     23  10000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     24  10000 ????						;			    This will allow conditional code to verify VCS.H being
     25  10000 ????						;			    used for code assembly.
     26  10000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     27  10000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     28  10000 ????						;			 mirrored reading/writing differences.	This is more a
     29  10000 ????						;			 readability issue, and binary compatibility with disassembled
     30  10000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     31  10000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     32  10000 ????						;			 which was broken by the use of segments in this file, as
     33  10000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     34  10000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     35  10000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     36  10000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     37  10000 ????						;						   it is safe to leave it undefined, and the base address will
     38  10000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     39  10000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     40  10000 ????						;			  - register definitions are now generated through assignment
     41  10000 ????						;			    in uninitialised segments.	This allows a changeable base
     42  10000 ????						;			    address architecture.
     43  10000 ????						; 1.0	22/MAR/2003		Initial release
     44  10000 ????
     45  10000 ????
     46  10000 ????						;-------------------------------------------------------------------------------
     47  10000 ????
     48  10000 ????						; TIA_BASE_ADDRESS
     49  10000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     50  10000 ????						; Normally 0, the base address should (externally, before including this file)
     51  10000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     52  10000 ????						; The reason is that this bankswitching scheme treats any access to locations
     53  10000 ????						; < $40 as a bankswitch.
     54  10000 ????
     55  10000 ????			   -	       IFNCONST	TIA_BASE_ADDRESS
     56  10000 ????			   -TIA_BASE_ADDRESS =	0
     57  10000 ????				       ENDIF
     58  10000 ????
     59  10000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     60  10000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     61  10000 ????						; *OR* by declaring the label before including this file, eg:
     62  10000 ????						; TIA_BASE_ADDRESS = $40
     63  10000 ????						;   include "vcs.h"
     64  10000 ????
     65  10000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     66  10000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     67  10000 ????						; for the mirrored ROM hardware registers.
     68  10000 ????
     69  10000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     70  10000 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     71  10000 ????						; they defaut to the TIA_BASE_ADDRESS.
     72  10000 ????
     73  10000 ????			   -	       IFNCONST	TIA_BASE_READ_ADDRESS
     74  10000 ????			   -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     75  10000 ????				       ENDIF
     76  10000 ????
     77  10000 ????			   -	       IFNCONST	TIA_BASE_WRITE_ADDRESS
     78  10000 ????			   -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     79  10000 ????				       ENDIF
     80  10000 ????
     81  10000 ????						;-------------------------------------------------------------------------------
     82  10000 ????
     83 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     84 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     85 U0000
     86 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     87 U0000
     88 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     89 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     90 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     91 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     92 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     93 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     94 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     95 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     96 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     97 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     98 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     99 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    100 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    101 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    102 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    103 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    104 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    105 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    106 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    107 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    108 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    109 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    110 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    111 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    112 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    113 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    114 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    115 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    116 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    117 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    118 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    119 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    120 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    121 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    122 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    123 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    124 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    125 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    126 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    127 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    128 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    129 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    130 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    131 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    132 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    133 U002d
    134 U002d							;-------------------------------------------------------------------------------
    135 U002d
    136 U000e ????				      SEG.U	TIA_REGISTERS_READ
    137 U0000					      ORG	TIA_BASE_READ_ADDRESS
    138 U0000
    139 U0000							;											bit 7	 bit 6
    140 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    141 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    142 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    143 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    144 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    145 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    146 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    147 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    148 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    149 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    150 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    151 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    152 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    153 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    154 U000e
    155 U000e							;-------------------------------------------------------------------------------
    156 U000e
    157 U0298 ????				      SEG.U	RIOT
    158 U0280					      ORG	$280
    159 U0280
    160 U0280							; RIOT MEMORY MAP
    161 U0280
    162 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    163 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    164 U0281
    165 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    166 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    167 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    168 U0284		       00	   INTIM      ds	1	; $284		Timer output
    169 U0285
    170 U0285		       00	   TIMINT     ds	1	; $285
    171 U0286
    172 U0286							; Unused/undefined registers ($285-$294)
    173 U0286
    174 U0286		       00		      ds	1	; $286
    175 U0287		       00		      ds	1	; $287
    176 U0288		       00		      ds	1	; $288
    177 U0289		       00		      ds	1	; $289
    178 U028a		       00		      ds	1	; $28A
    179 U028b		       00		      ds	1	; $28B
    180 U028c		       00		      ds	1	; $28C
    181 U028d		       00		      ds	1	; $28D
    182 U028e		       00		      ds	1	; $28E
    183 U028f		       00		      ds	1	; $28F
    184 U0290		       00		      ds	1	; $290
    185 U0291		       00		      ds	1	; $291
    186 U0292		       00		      ds	1	; $292
    187 U0293		       00		      ds	1	; $293
    188 U0294
    189 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    190 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    191 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    192 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    193 U0298
    194 U0298							;-------------------------------------------------------------------------------
    195 U0298							; The following required for back-compatibility with code which does not use
    196 U0298							; segments.
    197 U0298
    198  10000 ????				       SEG
    199  10000 ????
    200  10000 ????						; EOF
------- FILE spider.asm
------- FILE macro.h LEVEL 2 PASS 2
      0  10000 ????				       include	"macro.h"
      1  10000 ????						; MACRO.H
      2  10000 ????						; Version 1.06, 3/SEPTEMBER/2004
      3  10000 ????
      4  10000 ????		00 6a	    VERSION_MACRO =	106
      5  10000 ????
      6  10000 ????						;
      7  10000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  10000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
      9  10000 ????						;
     10  10000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     11  10000 ????						; It is distributed as a companion machine-specific support package
     12  10000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  10000 ????						; available at at http://www.atari2600.org/dasm
     14  10000 ????						;
     15  10000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     16  10000 ????						; contents, or would like to add something, please write to me
     17  10000 ????						; (atari2600@taswegian.com) with your contribution.
     18  10000 ????						;
     19  10000 ????						; Latest Revisions...
     20  10000 ????						;
     21  10000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     22  10000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     23  10000 ????						;			   This will allow conditional code to verify MACRO.H being
     24  10000 ????						;			   used for code assembly.
     25  10000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     26  10000 ????						;
     27  10000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     28  10000 ????						;
     29  10000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     30  10000 ????						;			   (standardised macro for vertical synch code)
     31  10000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     32  10000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     33  10000 ????						; 1.0	22/MAR/2003		Initial release
     34  10000 ????
     35  10000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     36  10000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     37  10000 ????						;   If you do not allow illegal opcode usage, you must include this file
     38  10000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     39  10000 ????						;   registers and require them to be defined first).
     40  10000 ????
     41  10000 ????						; Available macros...
     42  10000 ????						;   SLEEP n		 - sleep for n cycles
     43  10000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     44  10000 ????						;   CLEAN_START	 - set machine to known state on startup
     45  10000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     46  10000 ????
     47  10000 ????						;-------------------------------------------------------------------------------
     48  10000 ????						; SLEEP duration
     49  10000 ????						; Original author: Thomas Jentzsch
     50  10000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     51  10000 ????						; useful for code where precise timing is required.
     52  10000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     53  10000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     54  10000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     55  10000 ????
     56  10000 ????				       MAC	sleep
     57  10000 ????			    .CYCLES    SET	{1}
     58  10000 ????
     59  10000 ????				       IF	.CYCLES < 2
     60  10000 ????				       ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     61  10000 ????				       ERR
     62  10000 ????				       ENDIF
     63  10000 ????
     64  10000 ????				       IF	.CYCLES & 1
     65  10000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     66  10000 ????				       nop	0
     67  10000 ????				       ELSE
     68  10000 ????				       bit	VSYNC
     69  10000 ????				       ENDIF
     70  10000 ????			    .CYCLES    SET	.CYCLES - 3
     71  10000 ????				       ENDIF
     72  10000 ????
     73  10000 ????				       REPEAT	.CYCLES / 2
     74  10000 ????				       nop
     75  10000 ????				       REPEND
     76  10000 ????				       ENDM		;usage: SLEEP n (n>1)
     77  10000 ????
     78  10000 ????						;-------------------------------------------------------------------------------
     79  10000 ????						; VERTICAL_SYNC
     80  10000 ????						; revised version by Edwin Blink -- saves bytes!
     81  10000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     82  10000 ????						; Note: Alters the accumulator
     83  10000 ????
     84  10000 ????						; OUT: A = 0
     85  10000 ????
     86  10000 ????				       MAC	vertical_sync
     87  10000 ????				       lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     88  10000 ????			    .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     89  10000 ????				       sta	VSYNC
     90  10000 ????				       lsr
     91  10000 ????				       bne	.VSLP1	; branch until VYSNC has been reset
     92  10000 ????				       ENDM
     93  10000 ????
     94  10000 ????						;-------------------------------------------------------------------------------
     95  10000 ????						; CLEAN_START
     96  10000 ????						; Original author: Andrew Davie
     97  10000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     98  10000 ????						; Sets stack pointer to $FF, and all registers to 0
     99  10000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    100  10000 ????						; Use as very first section of code on boot (ie: at reset)
    101  10000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    102  10000 ????
    103  10000 ????				       MAC	clean_start
    104  10000 ????				       sei
    105  10000 ????				       cld
    106  10000 ????
    107  10000 ????				       ldx	#0
    108  10000 ????				       txa
    109  10000 ????				       tay
    110  10000 ????			    .CLEAR_STACK dex
    111  10000 ????				       txs
    112  10000 ????				       pha
    113  10000 ????				       bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    114  10000 ????
    115  10000 ????				       ENDM
    116  10000 ????
    117  10000 ????						;-------------------------------------------------------
    118  10000 ????						; SET_POINTER
    119  10000 ????						; Original author: Manuel Rotschkar
    120  10000 ????						;
    121  10000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    122  10000 ????						;
    123  10000 ????						; Usage: SET_POINTER pointer, address
    124  10000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    125  10000 ????						;
    126  10000 ????						; Note: Alters the accumulator, NZ flags
    127  10000 ????						; IN 1: 2 byte RAM location reserved for pointer
    128  10000 ????						; IN 2: absolute address
    129  10000 ????
    130  10000 ????				       MAC	set_pointer
    131  10000 ????			    .POINTER   SET	{1}
    132  10000 ????			    .ADDRESS   SET	{2}
    133  10000 ????
    134  10000 ????				       LDA	#<.ADDRESS	; Get Lowbyte of Address
    135  10000 ????				       STA	.POINTER	; Store in pointer
    136  10000 ????				       LDA	#>.ADDRESS	; Get Hibyte of Address
    137  10000 ????				       STA	.POINTER+1	; Store in pointer+1
    138  10000 ????
    139  10000 ????				       ENDM
    140  10000 ????
    141  10000 ????						;-------------------------------------------------------
    142  10000 ????						; BOUNDARY byte#
    143  10000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    144  10000 ????						;
    145  10000 ????						; Push data to a certain position inside a page and keep count of how
    146  10000 ????						; many free bytes the programmer will have.
    147  10000 ????						;
    148  10000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    149  10000 ????
    150  10000 ????			    .FREE_BYTES SET	0
    151  10000 ????				       MAC	boundary
    152  10000 ????				       REPEAT	256
    153  10000 ????				       IF	<. % {1} = 0
    154  10000 ????				       MEXIT
    155  10000 ????				       ELSE
    156  10000 ????			    .FREE_BYTES SET	.FREE_BYTES + 1
    157  10000 ????				       .byte	$00
    158  10000 ????				       ENDIF
    159  10000 ????				       REPEND
    160  10000 ????				       ENDM
    161  10000 ????
    162  10000 ????
    163  10000 ????						; EOF
------- FILE spider.asm
      9  10000 ????
     10  10000 ????						;================
     11  10000 ????						; Constants
     12  10000 ????						;================
     13  10000 ????
     14  10000 ????						; PAL Region
     15  10000 ????		00 00	    PAL        =	0
     16  10000 ????		00 f2	    PAL_SCANLINES =	242
     17  10000 ????		01 38	    PAL_TOTAL  =	312
     18  10000 ????
     19  10000 ????						; NTSC Region
     20  10000 ????		00 01	    NTSC       =	1
     21  10000 ????		00 c0	    NTSC_SCANLINES =	192
     22  10000 ????		01 06	    NTSC_TOTAL =	262
     23  10000 ????
     24  10000 ????						; Kernel
     25  10000 ????		00 01	    SYSTEM     =	NTSC
     26  10000 ????				       if	SYSTEM = NTSC
     27  10000 ????		00 c0	    KERNEL_SCANLINES =	NTSC_SCANLINES
     28  10000 ????		01 06	    KERNEL_TOTAL =	NTSC_TOTAL
     29  10000 ????				       endif
     30  10000 ????			   -	       if	SYSTEM = PAL
     31  10000 ????			   -KERNEL_SCANLINES =	PAL_SCANLINES
     32  10000 ????			   -KERNEL_TOTAL =	PAL_TOTAL
     33  10000 ????				       endif
     34  10000 ????		00 03	    KERNEL_VSYNC =	3
     35  10000 ????		00 25	    KERNEL_VBLANK =	37
     36  10000 ????		00 1e	    KERNEL_OVERSCAN =	30
     37  10000 ????
     38  10000 ????						; Logo
     39  10000 ????		00 09	    LOGO_SIZE  =	9
     40  10000 ????		00 30	    LOGO_START =	48
     41  10000 ????		00 08	    LOGO_INTERVAL =	8
     42  10000 ????		00 b4	    LOGO_FRAMES =	180
     43  10000 ????
     44  10000 ????		00 a2	    LOGO_BG_COLU =	#$A2
     45  10000 ????		00 5e	    LOGO_FG_COLU =	#$5E
     46  10000 ????
     47  10000 ????						; Title
     48  10000 ????		00 08	    TITLE_LINE_SIZE =	8
     49  10000 ????		00 04	    TITLE_DATA_SIZE =	%00000100
     50  10000 ????		00 01	    TITLE_BORDER =	1
     51  10000 ????		00 04	    TITLE_PAD  =	4
     52  10000 ????		00 06	    TITLE_IMAGE =	6
     53  10000 ????		00 02	    TITLE_GAP  =	2
     54  10000 ????
     55  10000 ????		00 70	    TITLE_BG_COLU =	#$70
     56  10000 ????		00 7e	    TITLE_BD_COLU =	#$7E
     57  10000 ????		00 0e	    TITLE_FG_COLU =	#$0E
     58  10000 ????
     59  10000 ????						;================
     60  10000 ????						; Variables
     61  10000 ????						;================
     62  10000 ????
     63 U0082 ????				      SEG.U	vars
     64 U0080					      org	$80
     65 U0080
     66 U0080		       00 00 00 00*Overlay    ds	8
     67 U0088
     68 U0080					      org	Overlay
     69 U0080
     70 U0080							; Animation/Logic System
     71 U0080
     72 U0080		       00	   AnimationFrame ds	1	; 1 byte to count frames
     73 U0081		       00	   AnimationSubFrame ds	1	; 1 byte to count portions of frames
     74 U0082
     75 U0080					      org	Overlay
     76 U0080
     77 U0080							; Drawing System, etc
     78 U0080
     79 U0080		       00 00	   TitleImagePtr ds	2	; Pointer to image data location
     80 U0082
     81  10000 ????				       SEG
     82  10000 ????
     83  f000					      ORG	$F000	; Start of cart area
     84  f000
     85  f000				   Reset
     86  f000
     87  f000				   .initstack
     88  f000
     89  f000		       a2 00		      ldx	#0
     90  f002		       8a		      txa
     91  f003
     92  f003				   .initstack_loop
     93  f003
     94  f003		       ca		      dex
     95  f004		       9a		      txs
     96  f005		       48		      pha
     97  f006		       d0 fb		      bne	.initstack_loop
     98  f008
     99  f008							; Stack pointer now $FF, a=x=0, TIA registers (0 - $7F) = RAM ($80 - $FF) = 0
    100  f008
    101  f008				   .initvars
    102  f008
    103  f008							; Set background color
    104  f008		       a9 00		      lda	#$00	; Black
    105  f00a		       85 09		      sta	COLUBK
    106  f00c
    107  f00c							; Set the playfield and player color
    108  f00c		       a9 0e		      lda	#$0E	; White
    109  f00e		       85 08		      sta	COLUPF
    110  f010		       85 06		      sta	COLUP0
    111  f012		       85 07		      sta	COLUP1
    112  f014
    113  f014							; Playfield Control
    114  f014		       a9 00		      lda	#%00000000	; 1 for mirroring
    115  f016		       85 0a		      sta	CTRLPF
    116  f018
    117  f018							; Disable Game Elements
    118  f018		       a9 00		      lda	#$00
    119  f01a		       85 1f		      sta	ENABL	; Turn off ball
    120  f01c		       85 1d		      sta	ENAM0	; Turn off player 1 missile
    121  f01e		       85 1e		      sta	ENAM1	; Turn off player 2 missile
    122  f020		       85 1b		      sta	GRP0	; Turn off player 1
    123  f022		       85 1c		      sta	GRP1	; Turn off player 2
    124  f024
    125  f024							; Empty playfield
    126  f024		       a9 00		      lda	#%00000000
    127  f026		       85 0d		      sta	PF0
    128  f028		       85 0e		      sta	PF1
    129  f02a		       85 0f		      sta	PF2
    130  f02c
    131  f02c				   LogoScreen
    132  f02c
    133  f02c							; Load Colors
    134  f02c		       a9 a2		      lda	#LOGO_BG_COLU
    135  f02e		       85 09		      sta	COLUBK
    136  f030		       a9 5e		      lda	#LOGO_FG_COLU
    137  f032		       85 08		      sta	COLUPF
    138  f034
    139  f034							; Load number of frames into AnimationFrame
    140  f034		       a9 b4		      lda	#LOGO_FRAMES
    141  f036		       85 80		      sta	AnimationFrame
    142  f038
    143  f038		       a9 00		      lda	#0
    144  f03a		       85 81		      sta	AnimationSubFrame
    145  f03c
    146  f03c				   LogoFrame
    147  f03c
    148  f03c				   .logo_vsync		; Start of vertical blank processing
    149  f03c
    150  f03c		       a9 00		      lda	#0
    151  f03e		       85 01		      sta	VBLANK
    152  f040
    153  f040		       a9 02		      lda	#2
    154  f042		       85 00		      sta	VSYNC
    155  f044
    156  f044							; VSYNCH signal scanlines
    157  f044					      REPEAT	#KERNEL_VSYNC
    158  f044		       85 02		      sta	WSYNC
    157  f044					      REPEND
    158  f046		       85 02		      sta	WSYNC
    157  f046					      REPEND
    158  f048		       85 02		      sta	WSYNC
    159  f04a					      REPEND
    160  f04a
    161  f04a		       a9 00		      lda	#0
    162  f04c		       85 00		      sta	VSYNC
    163  f04e
    164  f04e				   .logo_vblank 		; scanlines of vertical blank
    165  f04e
    166  f04e		       a2 25		      ldx	#KERNEL_VBLANK
    167  f050				   .logo_vblank_loop
    168  f050
    169  f050		       85 02		      sta	WSYNC
    170  f052		       ca		      dex
    171  f053		       d0 fb		      bne	.logo_vblank_loop
    172  f055
    173  f055				   .logo_scanline		; Do 192 scanlines
    174  f055
    175  f055		       a9 00		      lda	#$00	; Clear playfields
    176  f057		       85 0d		      sta	PF0
    177  f059		       85 0e		      sta	PF1
    178  f05b		       85 0f		      sta	PF2
    179  f05d
    180  f05d		       a2 30		      ldx	#LOGO_START	; This counts our scanline number
    181  f05f				   .logo_scanline_start
    182  f05f
    183  f05f		       85 02		      sta	WSYNC
    184  f061		       ca		      dex
    185  f062		       d0 fb		      bne	.logo_scanline_start
    186  f064
    187  f064		       a2 00		      ldx	#0
    188  f066				   .logo_scanline_loop
    189  f066
    190  f066							; Cleanup
    191  f066		       85 0e		      sta	PF1
    192  f068
    193  f068		       8a		      txa
    194  f069		       4a		      lsr		; Divide counter by 4
    195  f06a		       4a		      lsr
    196  f06b		       29 fe		      and	#%11111110	; Remove 0th bit
    197  f06d		       a8		      tay
    198  f06e
    199  f06e							; Check if we need to display line
    200  f06e		       c4 81		      cpy	AnimationSubFrame
    201  f070		       b0 17		      bcs	.logo_scanline_skip
    202  f072
    203  f072							; Load first half of data
    204  f072		       b9 0d f2 	      lda	LogoData,y
    205  f075		       85 0f		      sta	PF2
    206  f077
    207  f077							; Load second half of data
    208  f077		       c8		      iny
    209  f078		       b9 0d f2 	      lda	LogoData,y
    210  f07b
    211  f07b							; Use 4 MSB bits on PF0
    212  f07b		       85 0d		      sta	PF0
    213  f07d
    214  f07d							; Use 4 LSB bits on PF1
    215  f07d					      REPEAT	4
    216  f07d		       0a		      asl
    215  f07d					      REPEND
    216  f07e		       0a		      asl
    215  f07e					      REPEND
    216  f07f		       0a		      asl
    215  f07f					      REPEND
    216  f080		       0a		      asl
    217  f081					      REPEND
    218  f081		       85 0e		      sta	PF1
    219  f083
    220  f083							; Cleanup
    221  f083		       a9 00		      lda	#$00
    222  f085		       85 0f		      sta	PF2
    223  f087		       85 0d		      sta	PF0
    224  f089
    225  f089				   .logo_scanline_skip
    226  f089
    227  f089							; Clear Playfields
    228  f089		       a9 00		      lda	#$00
    229  f08b		       85 0d		      sta	PF0
    230  f08d		       85 0e		      sta	PF1
    231  f08f		       85 0f		      sta	PF2
    232  f091
    233  f091							; Wait for next line
    234  f091		       85 02		      sta	WSYNC
    235  f093
    236  f093							; Check if at end of logo display
    237  f093		       e8		      inx
    238  f094		       e0 48		      cpx	#LOGO_SIZE*LOGO_INTERVAL
    239  f096		       d0 ce		      bne	.logo_scanline_loop
    240  f098
    241  f098		       a2 48		      ldx	#KERNEL_SCANLINES-LOGO_START-LOGO_SIZE*LOGO_INTERVAL
    242  f09a				   .logo_scanline_end
    243  f09a
    244  f09a		       85 02		      sta	WSYNC
    245  f09c		       ca		      dex
    246  f09d		       d0 fb		      bne	.logo_scanline_end
    247  f09f
    248  f09f				   .logo_overscan		; 30 scanlines of overscan
    249  f09f
    250  f09f		       a9 42		      lda	#%01000010
    251  f0a1		       85 01		      sta	VBLANK	; end of screen - enter blanking
    252  f0a3
    253  f0a3		       a2 1e		      ldx	#KERNEL_OVERSCAN
    254  f0a5				   .logo_overscan_loop
    255  f0a5
    256  f0a5		       85 02		      sta	WSYNC
    257  f0a7		       ca		      dex
    258  f0a8		       d0 fb		      bne	.logo_overscan_loop
    259  f0aa
    260  f0aa		       a6 80		      ldx	AnimationFrame
    261  f0ac
    262  f0ac							; Divide inverted AnimationFrame by 4 and put in AnimationSubFrame
    263  f0ac		       a9 b4		      lda	#LOGO_FRAMES
    264  f0ae		       e5 80		      sbc	AnimationFrame
    265  f0b0		       4a		      lsr
    266  f0b1		       4a		      lsr
    267  f0b2		       85 81		      sta	AnimationSubFrame
    268  f0b4
    269  f0b4							; Decrement AnimationFrame
    270  f0b4		       ca		      dex
    271  f0b5		       86 80		      stx	AnimationFrame
    272  f0b7
    273  f0b7							; Check if we're at the end of the animation
    274  f0b7		       d0 83		      bne	LogoFrame
    275  f0b9
    276  f0b9				   TitleScreen
    277  f0b9
    278  f0b9							; Clear playfields
    279  f0b9		       a9 00		      lda	#$00
    280  f0bb		       85 0d		      sta	PF0
    281  f0bd		       85 0e		      sta	PF1
    282  f0bf		       85 0f		      sta	PF2
    283  f0c1
    284  f0c1							; Background Color
    285  f0c1		       a9 70		      lda	#TITLE_BG_COLU
    286  f0c3		       85 09		      sta	COLUBK
    287  f0c5
    288  f0c5							; Border Color
    289  f0c5		       a9 7e		      lda	#TITLE_BD_COLU
    290  f0c7		       85 08		      sta	COLUPF
    291  f0c9
    292  f0c9				   TitleFrame
    293  f0c9
    294  f0c9				   .title_vsync 		; Start of vertical blank processing
    295  f0c9
    296  f0c9		       a9 00		      lda	#0
    297  f0cb		       85 01		      sta	VBLANK
    298  f0cd
    299  f0cd		       a9 02		      lda	#2
    300  f0cf		       85 00		      sta	VSYNC
    301  f0d1
    302  f0d1							; VSYNCH signal scanlines
    303  f0d1					      REPEAT	#KERNEL_VSYNC
    304  f0d1		       85 02		      sta	WSYNC
    303  f0d1					      REPEND
    304  f0d3		       85 02		      sta	WSYNC
    303  f0d3					      REPEND
    304  f0d5		       85 02		      sta	WSYNC
    305  f0d7					      REPEND
    306  f0d7
    307  f0d7		       a9 00		      lda	#0
    308  f0d9		       85 00		      sta	VSYNC
    309  f0db
    310  f0db				   .title_vblank		; scanlines of vertical blank
    311  f0db
    312  f0db		       a2 25		      ldx	#KERNEL_VBLANK
    313  f0dd				   .title_vblank_loop
    314  f0dd
    315  f0dd		       85 02		      sta	WSYNC
    316  f0df		       ca		      dex
    317  f0e0		       d0 fb		      bne	.title_vblank_loop
    318  f0e2
    319  f0e2				   .title_border_h_top
    320  f0e2
    321  f0e2							; Number of Scanlines
    322  f0e2		       a2 08		      ldx	#TITLE_BORDER*TITLE_LINE_SIZE
    323  f0e4
    324  f0e4							; Draw Playfield
    325  f0e4		       a9 ff		      lda	#$FF
    326  f0e6		       85 0d		      sta	PF0
    327  f0e8		       85 0e		      sta	PF1
    328  f0ea		       85 0f		      sta	PF2
    329  f0ec
    330  f0ec				   .title_border_h_top_loop
    331  f0ec
    332  f0ec		       85 02		      sta	WSYNC
    333  f0ee		       ca		      dex
    334  f0ef		       d0 fb		      bne	.title_border_h_top_loop
    335  f0f1
    336  f0f1				   .title_border_v_top
    337  f0f1
    338  f0f1							; Number of Scanlines
    339  f0f1		       a2 20		      ldx	#TITLE_PAD*TITLE_LINE_SIZE
    340  f0f3
    341  f0f3							; Mirror playfield
    342  f0f3		       a9 01		      lda	#%00000001
    343  f0f5		       85 0a		      sta	CTRLPF
    344  f0f7
    345  f0f7							; Draw Playfield
    346  f0f7		       a9 10		      lda	#%00010000
    347  f0f9		       85 0d		      sta	PF0
    348  f0fb
    349  f0fb		       a9 00		      lda	#$00
    350  f0fd		       85 0e		      sta	PF1
    351  f0ff		       85 0f		      sta	PF2
    352  f101
    353  f101				   .title_border_v_top_loop
    354  f101
    355  f101		       85 02		      sta	WSYNC
    356  f103		       ca		      dex
    357  f104		       d0 fb		      bne	.title_border_v_top_loop
    358  f106
    359  f106				   .title_image_top
    360  f106
    361  f106		       a0 00		      ldy	#$00	; Current Image Index
    362  f108		       a2 08		      ldx	#TITLE_LINE_SIZE	; Current scanline
    363  f10a
    364  f10a		       4c 15 f1 	      jmp	.title_image_top_loop
    365  f10d
    366  f10d				   .title_image_top_loop_wait
    367  f10d
    368  f10d							; Wait until new line is ready to draw
    369  f10d		       85 02		      sta	WSYNC
      0  f10f					      sleep	11
      1  f10f				   .CYCLES    SET	11
      2  f10f
      3  f10f				  -	      IF	.CYCLES < 2
      4  f10f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f10f				  -	      ERR
      6  f10f					      ENDIF
      7  f10f
      8  f10f					      IF	.CYCLES & 1
      9  f10f					      IFNCONST	NO_ILLEGAL_OPCODES
     10  f10f		       04 00		      nop	0
     11  f111				  -	      ELSE
     12  f111				  -	      bit	VSYNC
     13  f111					      ENDIF
     14  f111				   .CYCLES    SET	.CYCLES - 3
     15  f111					      ENDIF
     16  f111
     17  f111					      REPEAT	.CYCLES / 2
     18  f111		       ea		      nop
     17  f111					      REPEND
     18  f112		       ea		      nop
     17  f112					      REPEND
     18  f113		       ea		      nop
     17  f113					      REPEND
     18  f114		       ea		      nop
     19  f115					      REPEND
    371  f115
    372  f115				   .title_image_top_loop
    373  f115
    374  f115							; Draw Image
    375  f115		       b9 1f f2 	      lda	TitleImageTop,y
    376  f118		       85 0e		      sta	PF1
    377  f11a		       c8		      iny
    378  f11b
    379  f11b							; Set Image Color
    380  f11b		       a9 0e		      lda	#TITLE_FG_COLU
    381  f11d		       85 08		      sta	COLUPF
    382  f11f
    383  f11f							; Finish Drawing Image
    384  f11f		       b9 1f f2 	      lda	TitleImageTop,y
    385  f122		       85 0f		      sta	PF2
    386  f124		       c8		      iny
    387  f125		       b9 1f f2 	      lda	TitleImageTop,y
    388  f128		       c8		      iny
      0  f129					      sleep	5
      1  f129				   .CYCLES    SET	5
      2  f129
      3  f129				  -	      IF	.CYCLES < 2
      4  f129				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f129				  -	      ERR
      6  f129					      ENDIF
      7  f129
      8  f129					      IF	.CYCLES & 1
      9  f129					      IFNCONST	NO_ILLEGAL_OPCODES
     10  f129		       04 00		      nop	0
     11  f12b				  -	      ELSE
     12  f12b				  -	      bit	VSYNC
     13  f12b					      ENDIF
     14  f12b				   .CYCLES    SET	.CYCLES - 3
     15  f12b					      ENDIF
     16  f12b
     17  f12b					      REPEAT	.CYCLES / 2
     18  f12b		       ea		      nop
     19  f12c					      REPEND
    390  f12c		       85 0f		      sta	PF2
    391  f12e		       b9 1f f2 	      lda	TitleImageTop,y
    392  f131		       85 0e		      sta	PF1
    393  f133
    394  f133							; Clear bottom of index
    395  f133		       98		      tya
    396  f134		       29 fc		      and	#%11111100
    397  f136		       a8		      tay
    398  f137
    399  f137							; Restore border color
      0  f137					      sleep	2
      1  f137				   .CYCLES    SET	2
      2  f137
      3  f137				  -	      IF	.CYCLES < 2
      4  f137				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f137				  -	      ERR
      6  f137					      ENDIF
      7  f137
      8  f137				  -	      IF	.CYCLES & 1
      9  f137				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f137				  -	      nop	0
     11  f137				  -	      ELSE
     12  f137				  -	      bit	VSYNC
     13  f137				  -	      ENDIF
     14  f137				  -.CYCLES    SET	.CYCLES - 3
     15  f137					      ENDIF
     16  f137
     17  f137					      REPEAT	.CYCLES / 2
     18  f137		       ea		      nop
     19  f138					      REPEND
    401  f138		       a9 7e		      lda	#TITLE_BD_COLU
    402  f13a		       85 08		      sta	COLUPF
    403  f13c
    404  f13c		       ca		      dex
    405  f13d		       d0 ce		      bne	.title_image_top_loop_wait
    406  f13f
    407  f13f							; Add 4 to the image index to skip to next line
    408  f13f					      REPEAT	4
    409  f13f		       c8		      iny
    408  f13f					      REPEND
    409  f140		       c8		      iny
    408  f140					      REPEND
    409  f141		       c8		      iny
    408  f141					      REPEND
    409  f142		       c8		      iny
    410  f143					      REPEND
    411  f143
    412  f143		       a2 08		      ldx	#TITLE_LINE_SIZE	; Current scanline
    413  f145
    414  f145		       c0 18		      cpy	#TITLE_IMAGE*TITLE_DATA_SIZE
    415  f147		       d0 cc		      bne	.title_image_top_loop
    416  f149
    417  f149				   .title_gap
    418  f149
    419  f149							; Number of Scanlines
    420  f149		       a2 10		      ldx	#TITLE_GAP*TITLE_LINE_SIZE
    421  f14b
    422  f14b							; Mirror playfield
    423  f14b		       a9 01		      lda	#%00000001
    424  f14d		       85 0a		      sta	CTRLPF
    425  f14f
    426  f14f							; Draw Playfield
    427  f14f		       a9 10		      lda	#%00010000
    428  f151		       85 0d		      sta	PF0
    429  f153
    430  f153		       a9 00		      lda	#$00
    431  f155		       85 0e		      sta	PF1
    432  f157		       85 0f		      sta	PF2
    433  f159
    434  f159				   .title_gap_loop
    435  f159
    436  f159		       85 02		      sta	WSYNC
    437  f15b		       ca		      dex
    438  f15c		       d0 fb		      bne	.title_gap_loop
    439  f15e
    440  f15e				   .title_image_bottom
    441  f15e
    442  f15e		       a0 00		      ldy	#$00	; Current Image Index
    443  f160		       a2 08		      ldx	#TITLE_LINE_SIZE
    444  f162
    445  f162		       4c 6d f1 	      jmp	.title_image_bottom_loop
    446  f165
    447  f165				   .title_image_bottom_loop_wait
    448  f165
    449  f165							; Wait until new line is ready to draw
    450  f165		       85 02		      sta	WSYNC
      0  f167					      sleep	11
      1  f167				   .CYCLES    SET	11
      2  f167
      3  f167				  -	      IF	.CYCLES < 2
      4  f167				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f167				  -	      ERR
      6  f167					      ENDIF
      7  f167
      8  f167					      IF	.CYCLES & 1
      9  f167					      IFNCONST	NO_ILLEGAL_OPCODES
     10  f167		       04 00		      nop	0
     11  f169				  -	      ELSE
     12  f169				  -	      bit	VSYNC
     13  f169					      ENDIF
     14  f169				   .CYCLES    SET	.CYCLES - 3
     15  f169					      ENDIF
     16  f169
     17  f169					      REPEAT	.CYCLES / 2
     18  f169		       ea		      nop
     17  f169					      REPEND
     18  f16a		       ea		      nop
     17  f16a					      REPEND
     18  f16b		       ea		      nop
     17  f16b					      REPEND
     18  f16c		       ea		      nop
     19  f16d					      REPEND
    452  f16d
    453  f16d				   .title_image_bottom_loop
    454  f16d
    455  f16d							; Draw Image
    456  f16d		       b9 37 f2 	      lda	TitleImageBottom,y
    457  f170		       85 0e		      sta	PF1
    458  f172		       c8		      iny
    459  f173
    460  f173							; Set Image Color
    461  f173		       a9 0e		      lda	#TITLE_FG_COLU
    462  f175		       85 08		      sta	COLUPF
    463  f177
    464  f177							; Finish Drawing Image
    465  f177		       b9 37 f2 	      lda	TitleImageBottom,y
    466  f17a		       85 0f		      sta	PF2
    467  f17c		       c8		      iny
    468  f17d		       b9 37 f2 	      lda	TitleImageBottom,y
    469  f180		       c8		      iny
      0  f181					      sleep	5
      1  f181				   .CYCLES    SET	5
      2  f181
      3  f181				  -	      IF	.CYCLES < 2
      4  f181				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f181				  -	      ERR
      6  f181					      ENDIF
      7  f181
      8  f181					      IF	.CYCLES & 1
      9  f181					      IFNCONST	NO_ILLEGAL_OPCODES
     10  f181		       04 00		      nop	0
     11  f183				  -	      ELSE
     12  f183				  -	      bit	VSYNC
     13  f183					      ENDIF
     14  f183				   .CYCLES    SET	.CYCLES - 3
     15  f183					      ENDIF
     16  f183
     17  f183					      REPEAT	.CYCLES / 2
     18  f183		       ea		      nop
     19  f184					      REPEND
    471  f184		       85 0f		      sta	PF2
    472  f186		       b9 37 f2 	      lda	TitleImageBottom,y
    473  f189		       85 0e		      sta	PF1
    474  f18b
    475  f18b							; Clear bottom of index
    476  f18b		       98		      tya
    477  f18c		       29 fc		      and	#%11111100
    478  f18e		       a8		      tay
    479  f18f
    480  f18f							; Restore border color
      0  f18f					      sleep	2
      1  f18f				   .CYCLES    SET	2
      2  f18f
      3  f18f				  -	      IF	.CYCLES < 2
      4  f18f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f18f				  -	      ERR
      6  f18f					      ENDIF
      7  f18f
      8  f18f				  -	      IF	.CYCLES & 1
      9  f18f				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f18f				  -	      nop	0
     11  f18f				  -	      ELSE
     12  f18f				  -	      bit	VSYNC
     13  f18f				  -	      ENDIF
     14  f18f				  -.CYCLES    SET	.CYCLES - 3
     15  f18f					      ENDIF
     16  f18f
     17  f18f					      REPEAT	.CYCLES / 2
     18  f18f		       ea		      nop
     19  f190					      REPEND
    482  f190		       a9 7e		      lda	#TITLE_BD_COLU
    483  f192		       85 08		      sta	COLUPF
    484  f194
    485  f194		       ca		      dex
    486  f195		       d0 ce		      bne	.title_image_bottom_loop_wait
    487  f197
    488  f197							; Add 4 to image index to skip to next line
    489  f197					      REPEAT	4
    490  f197		       c8		      iny
    489  f197					      REPEND
    490  f198		       c8		      iny
    489  f198					      REPEND
    490  f199		       c8		      iny
    489  f199					      REPEND
    490  f19a		       c8		      iny
    491  f19b					      REPEND
    492  f19b
    493  f19b		       a2 08		      ldx	#TITLE_LINE_SIZE	; Current scanline
    494  f19d
    495  f19d		       c0 18		      cpy	#TITLE_IMAGE*TITLE_DATA_SIZE
    496  f19f		       d0 cc		      bne	.title_image_bottom_loop
    497  f1a1
    498  f1a1				   .title_border_v_bottom
    499  f1a1
    500  f1a1							; Number of Scanlines
    501  f1a1		       a2 20		      ldx	#TITLE_PAD*TITLE_LINE_SIZE
    502  f1a3
    503  f1a3							; Mirror playfield
    504  f1a3		       a9 01		      lda	#%00000001
    505  f1a5		       85 0a		      sta	CTRLPF
    506  f1a7
    507  f1a7							; Draw Playfield
    508  f1a7		       a9 10		      lda	#%00010000
    509  f1a9		       85 0d		      sta	PF0
    510  f1ab
    511  f1ab		       a9 00		      lda	#$00
    512  f1ad		       85 0e		      sta	PF1
    513  f1af		       85 0f		      sta	PF2
    514  f1b1
    515  f1b1				   .title_border_v_bottom_loop
    516  f1b1
    517  f1b1		       85 02		      sta	WSYNC
    518  f1b3		       ca		      dex
    519  f1b4		       d0 fb		      bne	.title_border_v_bottom_loop
    520  f1b6
    521  f1b6				   .title_border_h_bottom
    522  f1b6
    523  f1b6							; Number of Scanlines
    524  f1b6		       a2 08		      ldx	#TITLE_BORDER*TITLE_LINE_SIZE
    525  f1b8
    526  f1b8							; Draw Playfield
    527  f1b8		       a9 ff		      lda	#$FF
    528  f1ba		       85 0d		      sta	PF0
    529  f1bc		       85 0e		      sta	PF1
    530  f1be		       85 0f		      sta	PF2
    531  f1c0
    532  f1c0				   .title_border_h_bottom_loop
    533  f1c0
    534  f1c0		       85 02		      sta	WSYNC
    535  f1c2		       ca		      dex
    536  f1c3		       d0 fb		      bne	.title_border_h_bottom_loop
    537  f1c5
    538  f1c5				   .title_overscan		; 30 scanlines of overscan
    539  f1c5
    540  f1c5		       a9 42		      lda	#%01000010
    541  f1c7		       85 01		      sta	VBLANK	; end of screen - enter blanking
    542  f1c9
    543  f1c9		       a2 1e		      ldx	#KERNEL_OVERSCAN
    544  f1cb				   .title_overscan_loop
    545  f1cb
    546  f1cb		       85 02		      sta	WSYNC
    547  f1cd		       ca		      dex
    548  f1ce		       d0 fb		      bne	.title_overscan_loop
    549  f1d0
    550  f1d0							; Check if Fire Button on controller 1 is pressed
    551  f1d0		       a5 0c		      lda	INPT4
    552  f1d2		       10 03		      bpl	StartScreen
    553  f1d4		       4c c9 f0 	      jmp	TitleFrame
    554  f1d7
    555  f1d7				   StartScreen
    556  f1d7
    557  f1d7							; Init variables here
    558  f1d7
    559  f1d7				   StartFrame
    560  f1d7
    561  f1d7				   .start_vsync 		; Start of vertical blank processing
    562  f1d7
    563  f1d7		       a9 00		      lda	#0
    564  f1d9		       85 01		      sta	VBLANK
    565  f1db
    566  f1db		       a9 02		      lda	#2
    567  f1dd		       85 00		      sta	VSYNC
    568  f1df
    569  f1df							; VSYNCH signal scanlines
    570  f1df					      REPEAT	#KERNEL_VSYNC
    571  f1df		       85 02		      sta	WSYNC
    570  f1df					      REPEND
    571  f1e1		       85 02		      sta	WSYNC
    570  f1e1					      REPEND
    571  f1e3		       85 02		      sta	WSYNC
    572  f1e5					      REPEND
    573  f1e5
    574  f1e5		       a9 00		      lda	#0
    575  f1e7		       85 00		      sta	VSYNC
    576  f1e9
    577  f1e9				   .start_vblank		; scanlines of vertical blank
    578  f1e9
    579  f1e9		       a2 25		      ldx	#KERNEL_VBLANK
    580  f1eb				   .start_vblank_loop
    581  f1eb
    582  f1eb		       85 02		      sta	WSYNC
    583  f1ed		       ca		      dex
    584  f1ee		       d0 fb		      bne	.start_vblank_loop
    585  f1f0
    586  f1f0				   .start_scanline		; Do 192 scanlines
    587  f1f0
    588  f1f0		       a9 08		      lda	#$08	; Clear playfields (with temp design)
    589  f1f2		       85 0d		      sta	PF0
    590  f1f4		       85 0e		      sta	PF1
    591  f1f6		       85 0f		      sta	PF2
    592  f1f8
    593  f1f8		       a2 c0		      ldx	#KERNEL_SCANLINES	; Iterate through all scanlines
    594  f1fa				   .start_scanline_loop
    595  f1fa
    596  f1fa		       85 02		      sta	WSYNC
    597  f1fc		       ca		      dex
    598  f1fd		       d0 fb		      bne	.start_scanline_loop
    599  f1ff
    600  f1ff				   .start_overscan		; 30 scanlines of overscan
    601  f1ff
    602  f1ff		       a9 42		      lda	#%01000010
    603  f201		       85 01		      sta	VBLANK	; end of screen - enter blanking
    604  f203
    605  f203		       a2 1e		      ldx	#KERNEL_OVERSCAN
    606  f205				   .start_overscan_loop
    607  f205
    608  f205		       85 02		      sta	WSYNC
    609  f207		       ca		      dex
    610  f208		       d0 fb		      bne	.start_overscan_loop
    611  f20a
    612  f20a		       4c d7 f1 	      jmp	StartFrame
    613  f20d
    614  f20d				   LogoData		; 6 bytes over 8 lines each, total of 48 lines
    615  f20d
    616  f20d		       00		      .BYTE.b	%00000000	; Reversed
    617  f20e		       10		      .BYTE.b	%00010000	; First 4 bits reversed
    618  f20f
    619  f20f		       80		      .BYTE.b	%10000000
    620  f210		       20		      .BYTE.b	%00100000
    621  f211
    622  f211		       40		      .BYTE.b	%01000000
    623  f212		       40		      .BYTE.b	%01000000
    624  f213
    625  f213		       20		      .BYTE.b	%00100000
    626  f214		       80		      .BYTE.b	%10000000
    627  f215
    628  f215		       10		      .BYTE.b	%00010000
    629  f216		       08		      .BYTE.b	%00001000
    630  f217
    631  f217		       08		      .BYTE.b	%00001000
    632  f218		       00		      .BYTE.b	%00000000
    633  f219
    634  f219		       04		      .BYTE.b	%00000100
    635  f21a		       00		      .BYTE.b	%00000000
    636  f21b
    637  f21b		       02		      .BYTE.b	%00000010
    638  f21c		       00		      .BYTE.b	%00000000
    639  f21d
    640  f21d		       ff		      .BYTE.b	%11111111
    641  f21e		       ff		      .BYTE.b	%11111111
    642  f21f
    643  f21f				   TitleImageTop		; Spider
    644  f21f
    645  f21f		       1e		      .BYTE.b	%00011110	; Normal
    646  f220		       77		      .BYTE.b	%01110111	; Reversed
    647  f221		       e7		      .BYTE.b	%11100111	; Normal
    648  f222		       0e		      .BYTE.b	%00001110	; Reversed
    649  f223
    650  f223		       10		      .BYTE.b	%00010000
    651  f224		       25		      .BYTE.b	%00100101
    652  f225		       94		      .BYTE.b	%10010100
    653  f226		       12		      .BYTE.b	%00010010
    654  f227
    655  f227		       10		      .BYTE.b	%00010000
    656  f228		       27		      .BYTE.b	%00100111
    657  f229		       96		      .BYTE.b	%10010110
    658  f22a		       12		      .BYTE.b	%00010010
    659  f22b
    660  f22b		       1c		      .BYTE.b	%00011100
    661  f22c		       21		      .BYTE.b	%00100001
    662  f22d		       94		      .BYTE.b	%10010100
    663  f22e		       0e		      .BYTE.b	%00001110
    664  f22f
    665  f22f		       04		      .BYTE.b	%00000100
    666  f230		       21		      .BYTE.b	%00100001
    667  f231		       94		      .BYTE.b	%10010100
    668  f232		       12		      .BYTE.b	%00010010
    669  f233
    670  f233		       1c		      .BYTE.b	%00011100
    671  f234		       71		      .BYTE.b	%01110001
    672  f235		       e7		      .BYTE.b	%11100111
    673  f236		       12		      .BYTE.b	%00010010
    674  f237
    675  f237				   TitleImageBottom		; Web & Art
    676  f237
    677  f237		       01		      .BYTE.b	%00000001	; Normal
    678  f238		       03		      .BYTE.b	%00000011	; Reversed
    679  f239		       8b		      .BYTE.b	%10001011	; Normal
    680  f23a		       1d		      .BYTE.b	%00011101	; Reversed
    681  f23b
    682  f23b		       0a		      .BYTE.b	%00001010
    683  f23c		       14		      .BYTE.b	%00010100
    684  f23d		       8a		      .BYTE.b	%10001010
    685  f23e		       24		      .BYTE.b	%00100100
    686  f23f
    687  f23f		       15		      .BYTE.b	%00010101
    688  f240		       2a		      .BYTE.b	%00101010
    689  f241		       8b		      .BYTE.b	%10001011
    690  f242		       1c		      .BYTE.b	%00011100
    691  f243
    692  f243		       24		      .BYTE.b	%00100100
    693  f244		       49		      .BYTE.b	%01001001
    694  f245		       8a		      .BYTE.b	%10001010
    695  f246		       24		      .BYTE.b	%00100100
    696  f247
    697  f247		       22		      .BYTE.b	%00100010
    698  f248		       44		      .BYTE.b	%01000100
    699  f249		       aa		      .BYTE.b	%10101010
    700  f24a		       24		      .BYTE.b	%00100100
    701  f24b
    702  f24b		       11		      .BYTE.b	%00010001
    703  f24c		       23		      .BYTE.b	%00100011
    704  f24d		       53		      .BYTE.b	%01010011
    705  f24e		       1d		      .BYTE.b	%00011101
    706  f24f
    707  f24f							;-------------------------------------------
    708  f24f
    709  fffa					      ORG	$FFFA	; End of cart area
    710  fffa
    711  fffa				   InterruptVectors
    712  fffa
    713  fffa		       00 f0		      .word.w	Reset	; NMI
    714  fffc		       00 f0		      .word.w	Reset	; RESET
    715  fffe		       00 f0		      .word.w	Reset	; IRQ
    716  10000
    717  10000					       END
